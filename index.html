<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edytor Mermaid.js z Pan/Zoom</title>
    <!-- Import czcionki Inter dla ładniejszego wyglądu -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Fira+Code&display=swap" rel="stylesheet">
    
    <!-- 1. Załadowanie biblioteki Panzoom -->
    <script src="https://unpkg.com/panzoom@9.4.3/dist/panzoom.min.js"></script>

    <style>
        /* Podstawowy reset stylów */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Zapobiega przewijaniu całej strony */
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }

        /* Główny kontener aplikacji (Flexbox) */
        #app-container {
            display: flex;
            height: 100vh; /* 100% wysokości okna przeglądarki */
            width: 100%;
        }

        /* Panel edytora (lewa strona) */
        #editor-pane {
            width: 30%; /* Początkowa szerokość */
            min-width: 200px; /* Minimalna szerokość edytora */
            flex-shrink: 0; /* Zapobiega kurczeniu się panelu */
            padding: 1rem;
            box-sizing: border-box;
            background-color: #ffffff;
            display: flex;
            flex-direction: column;
        }

        /* Pasek do zmiany rozmiaru */
        #resizer {
            flex: 0 0 8px; /* Stała szerokość 8px */
            background-color: #e5e7eb;
            cursor: col-resize;
            border-left: 1px solid #d1d5db;
            border-right: 1px solid #d1d5db;
        }
        #resizer:hover {
            background-color: #d1d5db; /* Podświetlenie przy najechaniu */
        }
        
        /* Klasa dodawana do body podczas przeciągania */
        body.is-resizing, body.is-resizing * {
            cursor: col-resize !important;
            user-select: none; /* Zapobiega zaznaczaniu tekstu */
        }

        /* Panel podglądu (prawa strona) */
        #preview-pane {
            flex: 1; /* Zajmuje resztę dostępnego miejsca */
            min-width: 300px; /* Minimalna szerokość podglądu */
            padding: 1.5rem;
            box-sizing: border-box;
            background-color: #f9fafb;
            overflow: hidden; 
            /* Usunięto właściwości flex, aby panzoom mógł w pełni kontrolować pozycjonowanie */
            /* display: flex; */
            /* justify-content: center; */
            /* align-items: flex-start; */
            cursor: grab;
        }

        /* Pole tekstowe do wpisywania kodu Mermaid */
        #markdown-input {
            width: 100%;
            flex-grow: 1; 
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'Fira Code', monospace; 
            font-size: 14px;
            line-height: 1.6;
            resize: none; 
            box-sizing: border-box;
            background-color: #fafafa;
        }

        #markdown-input:focus {
            outline: 2px solid #3b82f6;
            border-color: transparent;
        }

        /* Kontener na wyrenderowany diagram */
        #mermaid-output {
            /* Rozmiar zostanie dopasowany przez SVG wewnątrz */
        }
        
        /* Stylizacja komunikatów o błędach */
        .error-message {
            font-family: 'Fira Code', monospace;
            color: #ef4444;
            background-color: #fee2e2;
            padding: 1rem;
            border-radius: 8px;
            white-space: pre-wrap; 
        }
    </style>
</head>
<body>

    <!-- Główna struktura aplikacji -->
    <div id="app-container">
        
        <!-- Lewy panel: Edytor -->
        <div id="editor-pane">
            <textarea id="markdown-input"></textarea>
        </div>
        
        <!-- Separator -->
        <div id="resizer"></div>

        <!-- Prawy panel: Podgląd -->
        <div id="preview-pane">
            <div id="mermaid-output" class="mermaid">
                <!-- Diagram zostanie wyrenderowany tutaj -->
            </div>
        </div>

    </div>

    <!-- Załadowanie biblioteki Mermaid.js z CDN -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <script>
        // Domyślny tekst diagramu (POPRAWIONY - usunięto 'f' na końcu)
        const defaultMermaidCode = `flowchart LR
    A[Start] --> B(Proces 1)
    B --> C{Decyzja}
    C -->|Tak| D[Wynik A]
    C -->|Nie| E[Wynik B]
    D --> F[Koniec]
    E --> F[Koniec]`;

        // Inicjalizacja Mermaid.js
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default' 
        });

        // Czekamy, aż cała strona (DOM) się załaduje
        document.addEventListener('DOMContentLoaded', () => {
            
            // Pobieramy elementy DOM
            const editor = document.getElementById('markdown-input');
            const preview = document.getElementById('preview-pane');
            const mermaidContainer = document.getElementById('mermaid-output');
            const editorPane = document.getElementById('editor-pane');
            const resizer = document.getElementById('resizer');
            
            // Klucz do localStorage
            const storageKey = 'mermaidEditorContent';
            
            // --- NOWA LOGIKA: Klucz i zmienna dla stanu pan/zoom ---
            const transformStorageKey = 'mermaidEditorTransform';
            let savedTransform = null;

            const loadedTransform = localStorage.getItem(transformStorageKey);
            if (loadedTransform) {
                try {
                    savedTransform = JSON.parse(loadedTransform);
                } catch (e) {
                    console.error('Błąd parsowania zapisanego stanu transformacji:', e);
                    localStorage.removeItem(transformStorageKey); // Wyczyść błędne dane
                }
            }
            // --- Koniec nowej logiki ---
            
            // --- LOGIKA ZMIANY ROZMIARU PANELI ---
            let isResizing = false;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.classList.add('is-resizing');
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                e.preventDefault();
            });

            const handleMouseMove = (e) => {
                if (!isResizing) return;
                let newLeftWidth = e.clientX;
                const minEditorWidth = 200;
                const minPreviewWidth = 300;
                const totalWidth = document.body.clientWidth;
                const resizerWidth = resizer.offsetWidth;

                if (newLeftWidth < minEditorWidth) {
                    newLeftWidth = minEditorWidth;
                }
                if (totalWidth - newLeftWidth - resizerWidth < minPreviewWidth) {
                    newLeftWidth = totalWidth - minPreviewWidth - resizerWidth;
                }
                editorPane.style.width = `${newLeftWidth}px`;
            };

            const handleMouseUp = () => {
                isResizing = false;
                document.body.classList.remove('is-resizing');
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };

            // --- LOGIKA PAN & ZOOM ---
            
            // Zmienna przechowująca instancję panzoom
            let pzInstance = null;

            // Nasłuchiwanie na kółko myszy w panelu podglądu
            preview.addEventListener('wheel', (event) => {
                // Nie rób nic, jeśli panzoom nie jest aktywny (np. podczas błędu)
                if (!pzInstance) return; 

                event.preventDefault();

                const zoomSpeed = 0.05;
                const delta = event.deltaY > 0 ? -1 : 1; 
                const scaleMultiplier = Math.exp(delta * zoomSpeed);
                const currentScale = pzInstance.getTransform().scale;
                const newScale = currentScale * scaleMultiplier;
                
                // Oblicz pozycję myszy względem panelu podglądu
                const rect = preview.getBoundingClientRect();
                const clientX = event.clientX - rect.left;
                const clientY = event.clientY - rect.top;

                pzInstance.zoomAbs(clientX, clientY, newScale);
                
            }, { passive: false }); 

            // Zmiana kursora podczas przeciągania tła
            preview.addEventListener('mousedown', (e) => { 
                if (e.target === preview) { // Tylko jeśli kliknięto tło, nie diagram
                    preview.style.cursor = 'grabbing'; 
                }
            });
            preview.addEventListener('mouseup', () => { 
                preview.style.cursor = 'grab'; 
            });

            // --- LOGIKA RENDEROWANIA MERMAID ---
            const updatePreview = async () => {
                const code = editor.value;
                
                // Zapisz w localStorage przy każdej zmianie
                localStorage.setItem(storageKey, code);
                
                try {
                    const svgId = 'mermaid-svg-' + new Date().getTime();
                    const { svg } = await mermaid.render(svgId, code);

                    // --- ZMODYFIKOWANA LOGIKA: Zapisz stary stan PRZED zniszczeniem ---
                    let oldTransform = null;
                    // 1. Zniszcz (dispose) starą instancję panzoom, jeśli istnieje
                    if (pzInstance) {
                        oldTransform = pzInstance.getTransform(); // Zapisz pozycję
                        pzInstance.dispose(); // POPRAWKA: destroy -> dispose
                    }

                    // 2. Wstaw nowe SVG do kontenera
                    mermaidContainer.innerHTML = svg;

                    // --- ZMODYFIKOWANA LOGIKA: Użyj zapisanego stanu lub dopasuj do ekranu ---
                    let initialScale = 1;
                    let initialX = 0;
                    let initialY = 0;

                    // Sprawdź, czy mamy zapisany stan z POPRZEDNIEGO renderowania
                    if (oldTransform) {
                        initialScale = oldTransform.scale;
                        initialX = oldTransform.x;
                        initialY = oldTransform.y;
                    
                    // Jeśli nie, sprawdź, czy mamy zapisany stan z localStorage (pierwsze ładowanie)
                    } else if (savedTransform) {
                        // Jeśli tak, użyj go
                        initialScale = savedTransform.scale;
                        initialX = savedTransform.x;
                        initialY = savedTransform.y;
                        
                        // Wyczyść zapisany stan, aby kolejne renderowania (po zmianie tekstu)
                        // nie używały logiki "zoom-to-fit", a nie starej pozycji.
                        savedTransform = null; 

                    } else {
                        // --- INACZEJ, użyj logiki "zoom-to-fit" ---
                        const svgElement = mermaidContainer.querySelector('svg');
                        const containerWidth = preview.clientWidth; // Użyj clientWidth/Height
                        const containerHeight = preview.clientHeight;
                        const padding = 0.95; // 95% wypełnienia

                        // Upewnij się, że SVG istnieje i ma atrybuty width/height
                        if (svgElement && svgElement.width && svgElement.width.baseVal && svgElement.height && svgElement.height.baseVal) {
                            const svgWidth = svgElement.width.baseVal.value;
                            const svgHeight = svgElement.height.baseVal.value;

                            // Unikaj dzielenia przez zero, jeśli SVG ma zły rozmiar
                            if (svgWidth > 0 && svgHeight > 0) {
                                const scaleX = (containerWidth * padding) / svgWidth;
                                const scaleY = (containerHeight * padding) / svgHeight;
                                
                                initialScale = Math.min(scaleX, scaleY); // Dopasuj do mniejszego wymiaru
        
                                // Oblicz pozycję (x, y), aby wyśrodkować
                                const newSvgWidth = svgWidth * initialScale;
                                const newSvgHeight = svgHeight * initialScale;
                                
                                initialX = (containerWidth - newSvgWidth) / 2;
                                initialY = (containerHeight - newSvgHeight) / 2;
                            }
                        }
                        // --- Koniec logiki "zoom-to-fit" ---
                    }
                    // --- Koniec zmodyfikowanej logiki ---


                    // 3. Stwórz NOWĄ instancję panzoom na kontenerze,
                    //    który TERAZ zawiera już SVG.
                    pzInstance = panzoom(mermaidContainer, {
                        // minZoom: 0.2, // Usunięto na życzenie użytkownika
                        // maxZoom: 5,   // Usunięto na życzenie użytkownika
                        // bounds: true, 
                        // boundsPadding: 0.1,
                        // Ustaw początkową skalę i pozycję
                        initialX: initialX,
                        initialY: initialY,
                        initialZoom: initialScale,
                        smoothScroll: false
                    });

                    // --- NOWA LOGIKA: Dodaj listenery do zapisu stanu ---
                    const saveTransform = () => {
                        if (!pzInstance) return; // Upewnij się, że instancja wciąż istnieje
                        const transform = pzInstance.getTransform();
                        const transformState = {
                            scale: transform.scale,
                            x: transform.x,
                            y: transform.y
                        };
                        // Zapisz w localStorage
                        localStorage.setItem(transformStorageKey, JSON.stringify(transformState));
                    };
                    
                    // Zapisuj stan po zakończeniu przesuwania lub zoomowania
                    pzInstance.on('panend', saveTransform);
                    pzInstance.on('zoom', saveTransform); // 'zoom' jest emitowany po zakończeniu zoomu
                    // --- Koniec nowej logiki ---

                } catch (error) {
                    console.error('Błąd renderowania Mermaid:', error);
                    
                    // Jeśli wystąpił błąd, również zniszcz (dispose) instancję panzoom
                    if (pzInstance) {
                        pzInstance.dispose(); // POPRAWKA: destroy -> dispose
                        pzInstance = null;
                    }
                    
                    mermaidContainer.innerHTML = `<pre class="error-message">Błąd składni diagramu:\n\n${error.message}</pre>`;
                }
            };

            // Inicjalizacja aplikacji
            const savedCode = localStorage.getItem(storageKey);
            if (savedCode) {
                editor.value = savedCode;
            } else {
                editor.value = defaultMermaidCode;
            }
            
            editor.addEventListener('input', updatePreview);
            updatePreview(); // Pierwsze renderowanie
        });
    </script>

</body>
</html>





